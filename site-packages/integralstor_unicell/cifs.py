

from integralstor_common import command, common, services_management
from integralstor_common import cifs as cifs_common
from integralstor_unicell import local_users


def _generate_unicell_specific_global_section(f, d):
    try:
        if not f:
            raise Exception('No file handle passed')

        f.write("  server string = IntegralSTOR File server\n")
        f.write('  shadow: snapdir = .zfs/snapshot\n')
        f.write('  shadow: sort = desc\n')
        f.write('  shadow: format = zfs-auto-snap_%Y-%m-%d-%H%M\n')

        f.write('  vfs objects = acl_xattr\n')
        f.write('  map acl inherit = Yes\n')
        f.write('  store dos attributes = Yes\n')
        f.write('  nt acl support = Yes\n')
        f.write('  acl map full control = Yes\n')

        # Kill old sessions when request for new session is received from the same IP.
        # By activating this option, we ensure that all locks associated with an old
        # session will be released when a new session is established. However, this
        # has undesirable effects, if multiple clients share the same IP address
        # (e.g. because NAT is in use). However, in the LAN it is usually safe to
        # assume that every client will contact the server with its own IP
        # address.
        f.write('  reset on zero vc = yes\n')

        """
        f.write("  log file = /var/log/smblog.vfs\n")
        f.write("  log level=1 acls:3 locking:3\n")
        f.write("  oplocks=yes\n")
        f.write("  ea support=yes\n")
        f.write("  level2 oplocks=yes\n")
        f.write("  posix locking=no\n")
        f.write("  load printers = no\n")
        f.write("  map to guest = bad user\n")
        f.write("  idmap config *:backend = tdb\n")
        if 'workgroup' in d:
            f.write("  workgroup = %s\n" % d["workgroup"].upper())

        if d["security"] == "ads":
            f.write("  security = ADS\n")
            f.write("  preferred master = no\n")
            f.write("  encrypt passwords = yes\n")
            f.write("  winbind enum users  = yes\n")
            f.write("  winbind enum groups = yes\n")
            f.write("  winbind use default domain = yes\n")
            f.write("  winbind nested groups = yes\n")
            f.write("  winbind separator = +\n")
            f.write("  local master = no\n")
            f.write("  domain master = no\n")
            f.write("  wins proxy = no\n")
            f.write("  dns proxy = no\n")
            f.write("  winbind nss info = rfc2307\n")
            f.write("  winbind trusted domains only = no\n")
            f.write("  winbind refresh tickets = yes\n")
            f.write("  map untrusted to domain = Yes\n")
            if 'realm' in d:
                f.write("  realm = %s\n" % d["realm"].upper())
            if 'workgroup' in d:
                f.write("  idmap config %s:default = yes\n" %
                        d["workgroup"].upper())
                f.write("  idmap config %s:backend = ad\n" %
                        d["workgroup"].upper())
                if 'ad_schema_mode' in d:
                    f.write("  idmap config %s:schema_mode = %s\n" %
                            (d["workgroup"].upper(), d["ad_schema_mode"]))
                f.write("  idmap config %s:base_rid = 0\n" %
                        d["workgroup"].upper())
            f.write("  idmap config * :range = 16777216-33554431\n")
        """

    except Exception, e:
        return False, 'Error generating UNICell CIFS configuration - global section : %s' % str(e)
    else:
        return True, None


def _generate_unicell_specific_share_body(f, workgroup, path, read_only, browseable, comment, auth_method):
    try:
        if not f:
            raise Exception('No file handle passed')
        f.write('  vfs objects = shadow_copy2\n')

        # if comment:
        #    f.write("  comment = %s\n" % comment)
        #f.write("  path = %s\n" % path)
        #f.write("  kernel share modes = no\n")
        #f.write("  create mask = 0660\n")
        #f.write("  directory mask = 0770\n")
        # if read_only:
        #    f.write('  read only = yes\n')
        # else:
        #    f.write('  read only = no\n')
        # if browseable:
        #    f.write('  browseable = yes\n')
        # else:
        #    f.write('  browseable = no\n')

        f.write('  inherit permissions = yes\n')
        f.write('  inherit acls = yes\n')

    except Exception, e:
        return False, 'Error generating UNICell CIFS configuration - share body section : %s' % str(e)
    else:
        return True, None


def _generate_share_section(f, share_name, workgroup, path, read_only, browseable, comment, auth_method, extra_share_param_lines=None):
    try:
        if not f:
            raise Exception('No file handle passed')
        ret, err = cifs_common.generate_share_header(f, share_name)
        if err:
            raise Exception(err)
        ret, err = _generate_unicell_specific_share_body(
            f, workgroup, path, read_only, browseable, comment, auth_method)
        if err:
            raise Exception(err)
        ret, err = cifs_common.generate_common_share_body(
            f, workgroup, path, read_only, browseable, comment, extra_share_param_lines)
        if err:
            raise Exception(err)

    except Exception, e:
        return False, 'Error generating UNICell CIFS configuration file, shares section : %s' % str(e)
    else:
        return True, None


def generate_smb_conf():
    try:
        d, err = cifs_common.get_auth_settings()
        if err:
            raise Exception(err)
        smb_conf_path, err = common.get_smb_conf_path()
        if err:
            raise Exception(err)
        config_dir, err = common.get_config_dir()
        if err:
            raise Exception(err)

        # For customer specific or non configurable smb.conf lines
        extra_share_param_lines = None
        extra_global_param_lines = None
        if os.path.isfile('%s/customer_specific/extra_smb_share_params.conf' % config_dir):
            with open('%s/customer_specific/extra_smb_share_params.conf' % config_dir, 'r') as f1:
                extra_share_param_lines = f1.readlines()
        if os.path.isfile('%s/customer_specific/extra_smb_global_params.conf' % config_dir):
            with open('%s/customer_specific/extra_smb_global_params.conf' % config_dir, 'r') as f1:
                extra_global_param_lines = f1.readlines()
        # print extra_share_param_lines
        # print extra_global_param_lines
        with open("%s/smb.conf" % smb_conf_path, "w+") as f:
            ret, err = cifs_common.generate_global_header(f)
            if err:
                raise Exception(err)
            ret, err = _generate_unicell_specific_global_section(f, d)
            if err:
                raise Exception(err)
            ret, err = cifs_common.generate_common_global_section(
                f, d, extra_global_param_lines)
            if err:
                raise Exception(err)
            shl, err = cifs_common.get_shares_list()
            if err:
                raise Exception(err)
            if shl:
                for share in shl:
                    ret, err = _generate_share_section(
                        f, share["name"], d["workgroup"], share["path"], share["read_only"], share["browseable"], share["comment"], d["security"], extra_share_param_lines)
                    if err:
                        raise Exception(err)
        ret, errors = reload_configuration()
        if errors:
            raise Exception(errors)
    except Exception, e:
        return False, 'Error generating CIFS configuration : %s' % str(e)
    else:
        return True, None


def reload_configuration():
    try:
        use_salt, err = common.use_salt()
        if err:
            raise Exception(err)
        if use_salt:
            import salt.client
            errors = ''
            client = salt.client.LocalClient()
            r1 = client.cmd('*', 'cmd.run_all',
                            ['smbcontrol all reload-config'])
            if r1:
                for node, ret in r1.items():
                    # print ret
                    if ret["retcode"] != 0:
                        errors += "Error reloading samba on node %s " % node
            if errors:
                raise Exception(errors)
        else:
            cmd_to_run = 'smbcontrol all reload-config'
            lines, err = command.get_command_output(cmd_to_run)
            if err:
                raise Exception(err)
            ret, err = services_management.change_service_status(
                'winbind', 'restart')
            if err:
                raise Exception(err)
    except Exception, e:
        return False, 'Error reloading CIFS configuration : %s' % str(e)
    else:
        return True, None


def kinit(user, pswd, realm):
    try:
        cmd_to_run = 'echo "%s" | kinit %s@%s' % (pswd, user, realm.upper())
        # print cmd_to_run
        use_salt, err = common.use_salt()
        if err:
            raise Exception(err)
        if use_salt:
            import salt.client
            errors = []
            client = salt.client.LocalClient()
            # print 'Running %s'%cmd_to_run
            #assert False
            r1 = client.cmd('*', 'cmd.run_all', [cmd_to_run])
            if r1:
                for node, ret in r1.items():
                    # print ret
                    if ret["retcode"] != 0:
                        e = "Error initiating kerberos on GRIDCell %s" % node
                        if "stderr" in ret:
                            e += " : %s" % ret["stderr"]
                        errors.append(e)
                        print errors
            # print r1
            if errors:
                raise Exception(' '.join(errors))
        else:
            lines, err = command.get_command_output(cmd_to_run, shell=True)
            # print lines, err
            if err:
                raise Exception(err)
    except Exception, e:
        return False, 'Error initializing kerberos : %s' % str(e)
    else:
        return True, None


def net_ads_join(user, pswd, password_server):
    try:
        cmd_to_run = "net ads join -U %s%%%s" % (user, pswd)
        # print 'Running %s'%cmd_to_run
        use_salt, err = common.use_salt()
        if err:
            raise Exception(err)
        if use_salt:
            import salt.client
            errors = []
            client = salt.client.LocalClient()
            # print 'Running %s'%cmd_to_run
            #assert False
            r1 = client.cmd('*', 'cmd.run_all', [cmd_to_run])
            # print r1
            if r1:
                for node, ret in r1.items():
                    # print ret
                    if ret["retcode"] != 0:
                        e = "Error joining AD on node %s" % node
                        if "stderr" in ret:
                            e += " : %s" % ret["stderr"]
                        errors.append(e)
                        print errors
            # print r1
            if errors:
                raise Exception(' '.join(errors))
        else:
            lines, err = command.get_command_output(cmd_to_run)
            if err:
                raise Exception(err)
    except Exception, e:
        return False, 'Error joining AD : %s' % str(e)
    else:
        return True, None


def _get_user_or_group_list(type):
    ret = None
    try:
        d, err = cifs_common.get_auth_settings()
        if err:
            raise Exception(err)
        if not d:
            raise Exception(
                "Unspecified authentication method. Could not retrieve users")
        elif d["security"] == "users":
            if type and type == "users":
                l, err = local_users.get_local_users()
                if err:
                    raise Exception(err)
                if l:
                    ret = []
                    for ld in l:
                        ret.append(ld["username"])
            else:
                l, err = local_users.get_local_groups()
                if err:
                    raise Exception(err)
                if l:
                    ret = []
                    for ld in l:
                        ret.append(ld["grpname"])
        elif d["security"] == "ads":
            if type and type == "users":
                ret, err = cifs_common.get_ad_users_or_groups("users")
                if err:
                    raise Exception(err)
            elif type and type == "groups":
                ret, err = cifs_common.get_ad_users_or_groups("groups")
                if err:
                    raise Exception(err)
        else:
            raise Exception(
                "Unsupported authentication method. Could not retrieve users")
    except Exception, e:
        return None, 'Error retrieving user of group list : %s' % str(e)
    else:
        return ret, None


def get_user_list():
    ret = None
    try:
        ret, err = _get_user_or_group_list("users")
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving users list :%s' % str(e)
    else:
        return ret, None


def get_group_list():
    ret = None
    try:
        ret, err = _get_user_or_group_list("groups")
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving groups list :%s' % str(e)
    else:
        return ret, None


def main():
    with open('/tmp/z', 'w') as f:
        _generate_unicell_specific_share_body(f)
    pass


if __name__ == "__main__":
    main()

'''
def _generate_global_section(f, d):
  try:
    if not f:
      raise Exception('No file handle passed')
    f.write("; This file has been programatically generated by the IntegralStor system. Do not modify it manually!\n\n")
    f.write("[global]\n")
    f.write("  server string = Integralstor Unicell File server\n")
    f.write("  log file = /var/log/smblog.vfs\n")
    #f.write("  log level=5\n")
    f.write("  log level=1 acls:3 locking:3\n")
    f.write("  oplocks=yes\n")
    f.write("  ea support=yes\n")
    f.write("  level2 oplocks=yes\n")
    f.write("  posix locking=no\n")
    f.write("  load printers = no\n")
    f.write("  map to guest = bad user\n")
    f.write("  idmap config *:backend = tdb\n")
    f.write("  workgroup = %s\n"%d["workgroup"].upper())
    f.write("  netbios name = %s\n"%d["netbios_name"].upper())
    if d["security"] == "ads":
      f.write("  security = ADS\n")
      f.write("  preferred master = no\n")
      f.write("  encrypt passwords = yes\n")
      f.write("  winbind enum users  = yes\n")
      f.write("  winbind enum groups = yes\n")
      f.write("  winbind use default domain = yes\n")
      f.write("  winbind nested groups = yes\n")
      f.write("  winbind separator = +\n")
      f.write("  local master = no\n")
      f.write("  domain master = no\n")
      f.write("  wins proxy = no\n")
      f.write("  dns proxy = no\n")
      #f.write("  idmap config *:range = %d-%d \n"%(d["id_map_max"]+1, d["id_map_max"]+10001))
      f.write("  winbind nss info = rfc2307\n")
      f.write("  winbind trusted domains only = no\n")
      f.write("  winbind refresh tickets = yes\n")
      f.write("  map untrusted to domain = Yes\n")
      f.write("  realm = %s\n"%d["realm"].upper())
      f.write("  idmap config %s:default = yes\n"%d["workgroup"].upper())
      f.write("  idmap config %s:backend = ad\n"%d["workgroup"].upper())
      f.write("  idmap config %s:schema_mode = %s\n"%(d["workgroup"].upper(), d["ad_schema_mode"]))
      #f.write("  idmap config %s:range = %d-%d\n"%(d["workgroup"].upper(), d["id_map_min"], d["id_map_max"]))
      f.write("  idmap config %s:range = 16777216-33554431\n")
      f.write("  idmap config %s:base_rid = 0\n"%d["workgroup"].upper())
  except Exception, e:
    return False, 'Error generating CIFS configuration - global section : %s'%str(e)
  else:
    return True, None

def _generate_share_section(f, share_name, vol_name, workgroup, path, read_only, browseable, guest_ok, user_list, group_list, comment, auth_method):
  try:
    if not f:
      raise Exception('No file handle passed')
    f.write("\n[%s]\n"%share_name)
    if comment:
      f.write("  comment = %s\n"%comment)
    f.write("  path = %s\n"%path)
    f.write("  create mask = 0660\n")
    f.write("  kernel share modes = no\n")
    f.write("  directory mask = 0770\n")
    if read_only:
      t = "yes"
    else:
      t = "no"
    f.write("  read only = %s\n"%t)
    if user_list or group_list:
      s = "  valid users = "
      for user in user_list:
        if auth_method and auth_method == "users":
          s += " %s "%(user)
        else:
          s += " %s+%s "%(workgroup, user)
      for group in group_list:
        if auth_method and auth_method == "users":
          s += " @%s "%(group)
        else:
          s += " @%s+%s "%(workgroup, group)
      s += "\n"
      f.write(s)

    if browseable:
      t = "yes"
    else:
      t = "no"
    f.write("  browseable = %s\n"%t)
    if guest_ok:
      f.write("  guest ok = yes\n")
      #f.write("  guest account = %s\n"%guest_account)
  except Exception, e:
    return False, 'Error generating CIFS configuration file, shares section : %s'%str(e)
  else:
    return True, None

def reload_samba_services():
  try:
    use_salt, err = common.use_salt()
    if err:
      raise Exception(err)
    if use_salt:
      import salt.client
      client = salt.client.LocalClient()
      rc = client.cmd('*', 'service.reload', ['smbd'] )
      print rc
      rc = client.cmd('*', 'service.reload', ['winbind'] )
      print rc
      #rc = client.cmd('*', 'service.reload', ['nmbd'] )
      #print rc
    else:
      (ret, rc), err = command.execute_with_rc('service smb reload')
      if err:
        raise Exception(err)
      (ret, rc), err = command.execute_with_rc('service winbind reload')
      if err:
        raise Exception(err)
      if rc != 0:
        err = ''
        tl, er = command.get_output_list(ret)
        if er:
          raise Exception(er)
        if tl:
          err = ','.join(tl)
        tl, er = command.get_error_list(ret)
        if er:
          raise Exception(er)
        if tl:
          err = err + ','.join(tl)
        raise Exception("Return code : %d. Error : %s"%(rc, err))
      (ret, rc), err = command.execute_with_rc('service nmb reload')
      if err:
        raise Exception(err)
      if rc != 0:
        err = ''
        tl, er = command.get_output_list(ret)
        if er:
          raise Exception(er)
        if tl:
          err = ','.join(tl)
        tl, er = command.get_error_list(ret)
        if er:
          raise Exception(er)
        if tl:
          err = err + ','.join(tl)
        raise Exception("Return code : %d. Error : %s"%(rc, err))
  except Exception, e:
    return False, 'Error reloading CIFS services: %s'%str(e)
  else:
    return True, None
'''

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
