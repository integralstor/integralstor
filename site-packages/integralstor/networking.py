import socket
import re
import fcntl
import struct
import os
import shutil
import time
import netifaces
import unicodedata
import pprint
import time
import httplib
from urlparse import urlparse
from os import path

from integralstor import command, services_management, config

'''
  VALIDATION AND UTILITY FUNCTIONS
'''


def validate_netmask(mask):
    """Check the given netmask to see if its valid. True/False return."""
    valid = True
    try:
        nmatch = re.match(r"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)", mask)
        if nmatch:
            gr = nmatch.groups()
            if gr:
                for g in gr:
                    bits = bin(int(g))[2:].zfill(8)
                    # print int(g), bits
                    if int(g) != 0:
                        m = re.match(r'(1+)(0*)$', bits)
                        if not m:
                            # print 'invalid component - %s'%bits
                            valid = False
            else:
                valid = False
        else:
            valid = False
    except Exception, e:
        return False, "Error validating netmask : %s" % str(e)
    else:
        return valid, None


def _validate_ip_format(addr):
    """Check if the given address is a set of 4 numbers in dotted decimal."""
    ret = False
    try:
        test = re.compile('\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')
        result = test.match(addr)
        if result:
            ret = True
        else:
            ret = False
    except Exception, e:
        return False, "Error validating IP address format : %s" % str(e)
    else:
        return ret, None


def validate_ip(addr):
    """Check if the given address is a set of 4 numbers in dotted decimal AND in the 0-255 range."""
    ret = True
    try:
        if not _validate_ip_format(addr):
            ret = False
        if ret:
            match = re.search('([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)', addr)
            if match:
                ip_tup = match.groups()
                for i in range(4):
                    n = int(ip_tup[i])
                    # Some basic checks
                    if i in [0, 3]:
                        # First and last numbers cant be 0
                        if n == 0:
                            ret = False
                            break
                        if i == 3 and n == 255:
                            # Last number cant be 255
                            ret = False
                            break
                    if n < 0 or n > 255:
                        ret = False
                        break
            else:
                ret = False
    except Exception, e:
        return False, "Error validating IP address : %s" % str(e)
    else:
        return ret, None


def validate_hostname(hostname):
    """Ensure that the passed name is a valid hostname."""
    ret = True
    try:
        if len(hostname) > 255:
            ret = False
        if ret:
            if hostname.endswith("."):  # A single trailing dot is legal
                # strip exactly one dot from the right, if present
                hostname = hostname[:-1]
            disallowed = re.compile("[^A-Z\d-]", re.IGNORECASE)
            ret = all(  # Split by labels and verify individually
                (label and len(label) <= 63  # length is within proper range
                 # no bordering hyphens
                 and not label.startswith("-") and not label.endswith("-")
                 and not disallowed.search(label))  # contains only legal characters
                for label in hostname.split("."))
        if not ret:
            raise Exception('Invalid hostname')
    except Exception, e:
        return False, "Error validating hostname: %s" % str(e)
    else:
        return ret, None


def validate_ip_or_hostname(addr):
    """Some fields accept an IP or a hostname. This is a cover function to validate one or the other."""
    try:
        ret = False
        ok, err = _validate_ip_format(addr)
        if err:
            raise Exception('Error validating address : %s' % err)
        if ok:
            ok, err = validate_ip(addr)
            if err:
                raise Exception('Error validating IP address : %s' % err)
            ret = ok
        else:
            ok, err = validate_hostname(addr)
            if err:
                raise Exception('Error validating hostname : %s' % err)
            ret = ok
    except Exception, e:
        return False, "Error validating IP/hostname: %s" % str(e)
    else:
        return ret, None


def get_subnet_in_cidr_format(ip, subnet):
    """Given an IP and a subnet (as in 255.255..) string, returns the subnet info in CIDR format (as in 192.168.1.0/24)."""
    network_addr = None
    try:
        ipmatch = re.match(r"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)", ip)
        nmmatch = re.match(r"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)", subnet)
        nms = ""
        network_addr = ""
        if ipmatch and nmmatch:
            ipl = ipmatch.groups()
            nml = nmmatch.groups()
            i = 0
            while i < 4:
                binip = bin(int(ipl[i]))
                # print binip
                binnm = bin(int(nml[i]))
                nms += binnm[2:]
                # print binnm
                # print bin(int(ipl[i]) & int(nml[i]))
                network_addr += "%d" % (int(ipl[i]) & int(nml[i]))
                network_addr += '.'
                i += 1

        network_addr = network_addr[:(len(network_addr) - 1)]
        count = 0
        # print nms
        for a in nms:
            if a == '1':
                count += 1
            else:
                break
        network_addr += '/%d' % count
    except Exception, e:
        return None, "Error getting CIDR subnet : %s" % str(e)
    else:
        return network_addr, None


def can_connect(hostname, port, timeout=0.05):
    """Check connectivity to a given hostname/port combo."""
    connected = False
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)

        connected = True if s.connect_ex((hostname, port)) == 0 else False

    except Exception, e:
        return False, "Error checking connectivity: %s" % str(e)
    else:
        return connected, None


def can_ping(hostname):
    connected = False
    try:
        lines, err = command.get_command_output('ping -c 1 %s' % hostname)
        if not err:
            connected = True
    except Exception, e:
        return False, "Error checking ping : %s" % str(e)
    else:
        return connected, None


'''

  NIC BONDING FUNCTIONS

'''


def delete_bond(bond_name):
    """Delete a NIC bond."""
    modified_file_list = []
    try:
        if not bond_name:
            raise Exception('No bond name provided')

        #bond_name = unicodedata.normalize('NFKD', bond_name).encode('ascii','ignore')

        bm, err = get_bonding_masters()
        if err:
            raise Exception(err)

        if not bm or bond_name not in bm:
            raise Exception('Specified bond does not exist : %s' % err)

        bid, err = get_bonding_info_all()
        if err:
            raise Exception(err)
        if not bid:
            raise Exception('Specified bond configuration does not exist')

        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)

        if init_type not in ['systemd', 'init']:
            raise Exception("No Systemd or Init found. Not removing the bond.")
        elif init_type == 'systemd':
            cmd_bond = "nmcli con delete %s" % (bond_name)
            r, err = command.get_command_output(cmd_bond)
            if err:
                raise Exception(err)

            for slave in bid['by_master'][bond_name]['slaves']:
                cmd_slave = "nmcli con delete %s-%s" % (bond_name, slave)
                r, err = command.get_command_output(cmd_slave)
                if err:
                    raise Exception(err)

            ret, err = restart_networking()
            if not ret:
                if err:
                    raise Exception(err)
                else:
                    raise Exception("Error restarting networking services")

        elif init_type == 'init':
            ret, err = command.get_command_output('ifdown %s' % bond_name)
            if err:
                raise Exception("Error shutting down network bond: %s" % err)

            if os.path.isfile('/etc/modprobe.d/bonding.conf'):
                shutil.copyfile('/etc/modprobe.d/bonding.conf',
                                '/etc/modprobe.d/BAK.bonding.conf')
            with open('/etc/modprobe.d/bonding.conf', 'w') as f:
                if 'by_master' in bid and bid['by_master']:
                    for bn, binfo in bid['by_master'].items():
                        if bn == bond_name:
                            continue
                        f.write('alias %s bonding\n' % bn)
                        #f.write('options %s mode=%d miimon=100 downdelay=200 updelay=200\n'%(bn, int(binfo['mode_num'])))
            modified_file_list.append('/etc/modprobe.d/bonding.conf')

            for slave in bid['by_master'][bond_name]['slaves']:
                if os.path.isfile('/etc/sysconfig/network-scripts/ifcfg-%s' % slave):
                    shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s' %
                                    slave, '/etc/sysconfig/network-scripts/BAK.ifcfg-%s' % slave)
                with open('/etc/sysconfig/network-scripts/ifcfg-%s' % slave, 'w') as f:
                    f.write('DEVICE=%s\n' % slave)
                    f.write('USERCTL=no\n')
                    f.write('ONBOOT=yes\n')
                    f.write('NM_CONTROLLED=no\n')
                    f.write('SLAVE=no\n')
                    f.write('BOOTPROTO=none\n')
                modified_file_list.append(
                    '/etc/sysconfig/network-scripts/ifcfg-%s' % slave)
            if os.path.isfile('/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name):
                shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s' %
                                bond_name, '/etc/sysconfig/network-scripts/BAK.ifcfg-%s' % bond_name)
            if os.path.isfile('/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name):
                os.remove('/etc/sysconfig/network-scripts/ifcfg-%s' %
                          bond_name)
            modified_file_list.append(
                '/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name)
            # print type(bond_name)
            os.system('echo -%s > /sys/class/net/bonding_masters' % bond_name)
            ret, err = restart_networking()
            if not ret:
                if err:
                    raise Exception(err)
                else:
                    raise Exception("Error restarting networking services")
            # Now clean up all backed up files
            try:
                os.remove('/etc/modprobe.d/BAK.bonding.conf')
                os.remove(
                    '/etc/sysconfig/network-scripts/BAK.ifcfg-%s' % bond_name)
                filelist = glob.glob(
                    '/etc/sysconfig/network-scripts/BAK.ifcfg-*')
                for file in filelist:
                    os.remove(file)
            except Exception, e:
                pass

    except Exception, e:
        try:
            # Best effort cleanup
            if modified_file_list:
                for file in modified_file_list:
                    shutil.move('BAK.%s' % file, file)
        except Exception, e:
            pass
        return False, 'Error removing bond : %s' % str(e)
    else:
        return True, None


def delete_all_bonds():
    """Delete all NIC bonds."""
    error_list = []
    try:
        bm, err = get_bonding_masters()
        if err:
            raise Exception(err)
        if bm:
            for b in bm:
                ret, err = delete_bond(b)
                if err:
                    error_list.append(err)
        if error_list:
            raise Exception(str(error_list))

    except Exception, e:
        return False, 'Error removing bonds: %s' % str(e)
    else:
        return True, None


def delete_interfaces_connection(if_name=None):
    """Delete interface(s) connection profile. Applicable only for NetworkManager.

        If no argument is provided, remove all applicable interfaces.
    """

    error_list = []
    is_delete = False
    try:
        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)

        if init_type not in ['systemd']:
            raise Exception(
                'No Systemd/NetworkManager found. Not removing the connections.')

        interfaces, err = get_interfaces()
        if err:
            raise Exception(err)
        if if_name and interfaces and if_name not in interfaces:
            raise Exception('Invalid interface')
        for iface in interfaces.keys():
            if if_name and if_name != iface:
                continue
            if not interfaces[iface]['addresses']['is_sysd_ip4']:
                error_list.append('Interface %s is not part of NetworkManager' % iface)
                continue

            cmd_iface = 'nmcli con delete %s' % (iface)
            r, err = command.get_command_output(cmd_iface)
            if err:
                error_list.append(err)
            is_delete = True

        # Best effort service restart
        if is_delete == True:
            ret, err = restart_networking()
        else:
            error_list.append('Interface %s is not available; did not delete. If the interface is down, please retry after bringing it up.' % if_name)
        if error_list:
            raise Exception(str(error_list))

    except Exception, e:
        return False, 'Error removing interface connection(s): %s' % str(e)
    else:
        return True, None


def create_bond(bond_name, slaves, mode, bootproto=None, addr_info=None):
    """Create a NIC bond."""
    modified_file_list = []
    try:
        if not slaves:
            raise Exception('No slave interfaces provided')
        if not bond_name:
            raise Exception('No bond name provided')
        if not mode or mode not in [4, 6]:
            raise Exception('Specified mode not supported')
        # print 'mode=%s'%mode

        bm, err = get_bonding_masters()
        if err:
            raise Exception(err)
        if bm and bond_name in bm:
            raise Exception('A bond of the name already exists')

        bid, err = get_bonding_info_all()
        if err:
            raise Exception(err)
        if bid:
            for slave in slaves:
                if slave in bid['by_slave']:
                    raise Exception(
                        'Interface %s is already part of another bond' % slave)

        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)

        if init_type not in ['systemd', 'init']:
            raise Exception("No Systemd or Init found. Not creating the bond.")
        elif init_type == 'systemd':
            cmd_bond = "nmcli con add type bond con-name %s ifname %s mode %d" % (
                bond_name, bond_name, mode)
            r, err = command.get_command_output(cmd_bond)
            if err:
                raise Exception(err)
            else:
                for slave in slaves:
                    # regardless of returned error on executing cmd_del,
                    # cmd_down
                    cmd_del = "nmcli con del %s" % slave
                    r, err = command.get_command_output(cmd_del)

                    cmd_down = "ifdown %s" % slave
                    r, err = command.get_command_output(cmd_down)

                    cmd_slave = "nmcli con add autoconnect yes type bond-slave con-name %s-%s ifname %s master %s" % (
                        bond_name, slave, slave, bond_name)
                    r, err = command.get_command_output(cmd_slave)
                    if err:
                        raise Exception(err)
                    if_slave = "%s-%s" % (bond_name, slave)
                    cmd_con_up = "nmcli con up %s" % if_slave
                    r, err = command.get_command_output(cmd_con_up)
                    if err:
                        raise Exception(err)

        elif init_type == 'init':
            # All ok now so go ahead
            if os.path.isfile('/etc/modprobe.d/bonding.conf'):
                shutil.copyfile('/etc/modprobe.d/bonding.conf',
                                '/etc/modprobe.d/BAK.bonding.conf')
            # print 'a1'
            with open('/etc/modprobe.d/bonding.conf', 'a') as f:
                """
                if 'by_master' in bid and bid['by_master']:
                  for bn, binfo in bid['by_master'].items():
                    #print binfo
                    f.write('alias %s bonding\n'%bn)
                    #f.write('options %s mode=%d miimon=100 downdelay=200 updelay=200\n'%(bn, int(binfo['mode_num'])))
                """
                f.write('alias %s bonding\n' % bond_name)
                #f.write('options %s mode=%d miimon=100 downdelay=200 updelay=200\n'%(bond_name, mode))
            # print 'a2'

            modified_file_list.append('/etc/modprobe.d/bonding.conf')

            for slave in slaves:
                shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s' %
                                slave, '/etc/sysconfig/network-scripts/BAK.ifcfg-%s' % slave)
                with open('/etc/sysconfig/network-scripts/ifcfg-%s' % slave, 'w') as f:
                    f.write('DEVICE=%s\n' % slave)
                    f.write('USERCTL=no\n')
                    f.write('ONBOOT=yes\n')
                    f.write('NM_CONTROLLED=no\n')
                    f.write('MASTER=%s\n' % bond_name)
                    f.write('SLAVE=yes\n')
                    f.write('BOOTPROTO=none\n')
                modified_file_list.append(
                    '/etc/sysconfig/network-scripts/ifcfg-%s' % slave)
            if os.path.isfile('/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name):
                shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s' %
                                bond_name, '/etc/sysconfig/network-scripts/BAK.ifcfg-%s' % bond_name)
            with open('/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name, 'w') as f:
                f.write('#Generated by the IntegralStor script\n')
                f.write('DEVICE=%s\n' % bond_name)
                if not bootproto:
                    f.write('BOOTPROTO=none\n')
                elif bootproto == 'dhcp':
                    f.write('BOOTPROTO=dhcp\n')
                elif bootproto == 'static':
                    f.write('IPADDR=%s\n' % addr_info[0])
                    f.write('NETMASK=%s\n' % addr_info[1])
                    if len(addr_info) > 2:
                        f.write('GATEWAY=%s\n' % addr_info[2])
                    f.write('BOOTPROTO=none\n')
                f.write('MTU=1500\n')
                f.write('NM_CONTROLLED=no\n')
                f.write('ONBOOT=yes\n')
                f.write('USERCTL=no\n')
                f.write(
                    'BONDING_OPTS="mode=%d miimon=100 downdelay=200 updelay=200"\n' % mode)
            modified_file_list.append(
                '/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name)
            os.system('echo +%s > /sys/class/net/bonding_masters' % bond_name)
            ret, err = restart_networking()
            if not ret:
                if err:
                    raise Exception(err)
                else:
                    raise Exception("Error restarting networking services")

    except Exception, e:
        try:
            if modified_file_list:
                for file in modified_file_list:
                    shutil.move('BAK.%s' % file, file)
        except Exception, e:
            pass
        return False, 'Error configuring bond : %s' % str(e)
    else:
        return True, None


def get_bonding_type(bondname):
    """Return the bonding mode of the bond."""
    mode = -1
    try:
        with open('/sys/class/net/%s/bonding/mode' % bondname, 'r') as f:
            lines = f.readlines()
            if lines:
                comps = lines[0].strip().split()
                if comps and len(comps) == 2:
                    mode_str = comps[1].strip()
                    mode = int(mode_str)
        if mode == -1:
            with open('/etc/modprobe.d/bonding.conf', 'r') as f:
                for line in f:
                    if bondname not in line:
                        continue
                    fields = line.strip().split()
                    if fields and fields[0].lower() == 'options':
                        r = re.match('[\s\S]*mode=([0-9])', line.strip())
                        if r:
                            mode_str = r.groups()[0]
                            if mode_str:
                                mode = int(mode_str)
    except Exception, e:
        # print e
        return mode, 'Error retrieving bonding type : %s' % str(e)
    else:
        return mode, None


def update_bond_ip(d):
    """Set the IP addr of the bond."""
    try:
        with open('/etc/sysconfig/network-scripts/ifcfg-bond0', 'w') as f:
            f.write('#Generated by the IntegralStor script\n')
            f.write('DEVICE=bond0\n')
            f.write('IPADDR=%s\n' % d['ip'])
            f.write('NETMASK=%s\n' % d['netmask'])
            f.write('GATEWAY=%s\n' % d['default_gateway'])
            f.write('MTU=%s\n' % d['mtu'])
            f.write('NM_CONTROLLED=no\n')
            f.write('BOOTPROTO=none\n')
            f.write('ONBOOT=yes\n')
            f.write('USERCTL=no\n')
            f.flush()
        f.close()
    except Exception, e:
        return False, 'Error setting bond IP information : %s' % str(e)
    else:
        return True, None


def get_bonding_masters():
    """Get all the bonds in existence."""
    masters = []
    try:
        if os.path.isfile('/sys/class/net/bonding_masters'):
            with open('/sys/class/net/bonding_masters', 'r') as f:
                lines = f.readlines()
                if lines:
                    for line in lines:
                        masters += (line.strip().split())
    except Exception, e:
        return None, 'Error retrieving bonding masters: %s' % str(e)
    else:
        return masters, None


def get_bonding_info(bond_name, bonding_masters=None):
    """Get information about a bond."""
    return_dict = None
    try:
        if not bond_name:
            raise Exception('No bond name specified')
        # print bond_name
        if not bonding_masters:
            bonding_masters, err = get_bonding_masters()
            if err:
                raise Exception(err)
        # print '2'
        if bonding_masters and bond_name in bonding_masters:
            return_dict = {}
            # print '3'
            with open('/sys/class/net/%s/mtu' % bond_name, 'r') as f:
                mtu = int(f.readline().strip())
                return_dict['mtu'] = mtu
            # print '4'
            '''
            with open('/sys/class/net/%s/duplex'%bond_name, 'r') as f:
            duplex = f.readline()
            if duplex:
              duplex = duplex.strip()
            return_dict['duplex'] = duplex
            #print '5'
            with open('/sys/class/net/%s/speed'%bond_name, 'r') as f:
            speed = f.readline().strip()
            return_dict['speed'] = speed
            #print '6'
            with open('/sys/class/net/%s/bonding/active_slave'%bond_name, 'r') as f:
            active_slave = f.readline().strip()
            return_dict['active_slave'] = active_slave
            ##print '7'
            '''
            with open('/sys/class/net/%s/bonding/slaves' % bond_name, 'r') as f:
                slaves_str = f.readline().strip()
                slaves = slaves_str.split()
                return_dict['slaves'] = slaves
            # print '8'
            with open('/sys/class/net/%s/bonding/mii_status' % bond_name, 'r') as f:
                mii_status = f.readline().strip()
                return_dict['mii_status'] = mii_status
            # print '9'
            with open('/sys/class/net/%s/bonding/mode' % bond_name, 'r') as f:
                mode_str = f.readline().strip()
                mode = mode_str.split()
                return_dict['mode_str'] = mode[0]
                return_dict['mode_num'] = mode[1]
            # print '10'
            with open('/sys/class/net/%s/bonding/downdelay' % bond_name, 'r') as f:
                downdelay = int(f.readline().strip())
                return_dict['downdelay'] = downdelay
            # print '11'
            with open('/sys/class/net/%s/bonding/updelay' % bond_name, 'r') as f:
                updelay = int(f.readline().strip())
                return_dict['updelay'] = updelay
            # print '12'
    except Exception, e:
        return None, 'Error retrieving bonding information: %s' % str(e)
    else:
        return return_dict, None


def get_bonding_info_all():
    """Get info about all the bonds in existence."""
    return_dict = {}
    try:
        masters, err = get_bonding_masters()
        if err:
            raise Exception(err)
        return_dict['by_master'] = {}
        return_dict['by_slave'] = {}
        if masters:
            for master in masters:
                bond, err = get_bonding_info(master, masters)
                if err:
                    raise Exception(err)
                return_dict['by_master'][master] = bond
                for slave in bond['slaves']:
                    if slave not in return_dict['by_slave']:
                        return_dict['by_slave'][slave] = master

    except Exception, e:
        return None, 'Error retrieving all bonding information: %s' % str(e)
    else:
        return return_dict, None


'''

  FUNCTIONS TO SET AND GET VARIOUS INFO FOR AN INTERFACE

'''


def get_interfaces():
    """Get info about all existing interfaces."""
    if_dict = {}
    try:
        bonding_masters = None
        bonding_slaves = None
        il = netifaces.interfaces()
        # print il
        gwd, err = get_all_gateways()
        bm, err = get_bonding_info_all()
        if err:
            raise Exception(err)
        if bm:
            bonding_slaves = bm['by_slave']
            bonding_masters = bm['by_master']
        for i in il:
            if i.startswith('lo'):
                continue

            d = {}
            d['addresses'] = {}
            d['addresses']['is_sysd_ip4'] = False
            d['vlan_ids'] = []
            d['gateways'] = []
            d['bootproto'] = ''
            d['vlan'] = False

            d['carrier_status'], err = get_interface_carrier_status(i)
            d['up_status'], err = get_interface_up_status(i)
            d['speed'], err = get_interface_speed(i)
            d['mtu'], err = get_interface_mtu(i)

            addresses = netifaces.ifaddresses(i)
            if netifaces.AF_INET in addresses:
                d['addresses']['AF_INET'] = addresses[netifaces.AF_INET]
            if netifaces.AF_INET6 in addresses:
                d['addresses']['AF_INET6'] = addresses[netifaces.AF_INET6]
            if netifaces.AF_LINK in addresses:
                d['addresses']['AF_LINK'] = addresses[netifaces.AF_LINK]
            init_type, err = config.get_init_type()
            if err:
                raise Exception(err)
            if init_type == 'systemd':
                cmd = 'nmcli -t con show %s | grep -ie ip4.address | cut -d : -f 2' % i
                ret, err = command.get_command_output(cmd, shell=True)
                if ret:
                    d['addresses']['is_sysd_ip4'] = True

            if bm and i in bm:
                d['bonding_master'] = True
            if bonding_masters and i in bonding_masters:
                d['bonding_master'] = True
            if bonding_slaves and i in bonding_slaves:
                d['slave_to'] = bonding_slaves[i]

            # If the system had modified/renamed interfaces, ifcfg-*
            # file might be missing; forthcoming calls in this block
            # need this file to be present.
            # The file becomes available when the interface is
            # configured; so, read this file only when it is configured
            if not os.path.isfile('/etc/sysconfig/network-scripts/ifcfg-%s' % i):
                if_dict[i] = d
                continue
            bootproto, err = get_interface_bootproto(i)
            gateway, err = get_interface_default_gateway(i)
            is_vlan, err = is_interface_a_vlan(i)
            # print gateway, err
            if gateway:
                d['gateways'].append((gateway, i, True))
            d['bootproto'] = bootproto
            d['vlan'] = is_vlan
            #d['enabled_status'], err = get_interface_enabled_status(i)
            if_dict[i] = d

        for ifname, id in if_dict.items():
            if 'vlan' in id and id['vlan']:
                vlan_comps = ifname.split('.')
                if not vlan_comps or len(vlan_comps) != 2:
                    raise Exception('Incorrect VLAN naming : %s' % ifname)
                if vlan_comps[0] not in if_dict.keys():
                    raise Exception(
                        'Incorrectly configured VLAN : %s. Base NIC missing.' % ifname)
                if_dict[vlan_comps[0]]['vlan_ids'].append(int(vlan_comps[1]))
    except Exception, e:
        return None, 'Error retrieving interfaces : %s' % str(e)
    else:
        return if_dict, None


def get_ip_info(ifname):
    """Get the IP addr info for the interface."""
    ip_info = {}
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        ip_info["ipaddr"] = socket.inet_ntoa(fcntl.ioctl(
            s.fileno(), 0x8915,  struct.pack('256s', ifname[:15]))[20:24])
        ip_info["netmask"] = socket.inet_ntoa(fcntl.ioctl(
            s.fileno(), 35099, struct.pack('256s', ifname))[20:24])
        """Read the default gateway directly from /proc."""
        with open("/proc/net/route") as fh:
            for line in fh:
                fields = line.strip().split()
                if fields[1] != '00000000' or not int(fields[3], 16) & 2:
                    continue
                else:
                    ip_info["default_gateway"] = socket.inet_ntoa(
                        struct.pack("<L", int(fields[2], 16)))
                    break
    except Exception, e:
        return None, 'Error retrieving IP info : %s' % str(e)
    else:
        return ip_info, None


def get_interface_carrier_status(if_name):
    status = 'unknown'
    try:
        if os.path.isfile('/sys/class/net/%s/carrier' % if_name):
            with open('/sys/class/net/%s/carrier' % if_name, 'r') as f:
                line = f.readline()
                status = int(line.strip())
                if status == 1:
                    status = 'connected'
                elif status == 0:
                    status = 'disconnected'
    except Exception, e:
        return None, 'Error retrieving interface carrier status: %s' % str(e)
    else:
        return status, None


def get_interface_speed(if_name):
    speed = 'unknown'
    try:
        if os.path.isfile('/sys/class/net/%s/speed' % if_name):
            with open('/sys/class/net/%s/speed' % if_name, 'r') as f:
                line = f.readline()
                speed = int(line.strip())
    except Exception, e:
        return None, 'Error retrieving interface speed: %s' % str(e)
    else:
        return speed, None


def get_interface_mtu(if_name):
    mtu = 'unknown'
    try:
        if os.path.isfile('/sys/class/net/%s/mtu' % if_name):
            with open('/sys/class/net/%s/mtu' % if_name, 'r') as f:
                line = f.readline()
                mtu = int(line.strip())
    except Exception, e:
        return None, 'Error retrieving interface mtu: %s' % str(e)
    else:
        return mtu, None


def get_interface_up_status(if_name):
    status = 'unknown'
    try:
        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)

        if init_type not in ['systemd', 'init']:
            raise Exception("No Systemd or Init found.")
        elif init_type == 'systemd':
            bid, err = get_bonding_info_all()
            if err:
                raise Exception(err)
            cmd = ''
            if if_name in bid['by_slave']:
                cmd = 'nmcli -t con show %s-%s | grep -ie general.state | cut -d : -f 2' % (
                    bid['by_slave'][if_name], if_name)
            else:
                cmd = 'nmcli -t con show %s | grep -ie general.state | cut -d : -f 2' % if_name

            ret, err = command.get_command_output(cmd, shell=True)
            # if err, status remains as 'unknown'
            if ret and ret[0] == 'activated':
                status = 'up'
            elif not err:
                status = 'down'

        elif init_type == 'init':
            if os.path.isfile('/sys/class/net/%s/operstate' % if_name):
                with open('/sys/class/net/%s/operstate' % if_name, 'r') as f:
                    line = f.readline()
                    status = line.strip()
    except Exception, e:
        return None, 'Error retrieving interfaces status : %s' % str(e)
    else:
        return status, None


def get_interface_enabled_status(if_name):
    status = 'unknown'
    try:
        if os.path.isfile('/sys/class/net/%s/device/enable' % if_name):
            with open('/sys/class/net/%s/device/enable' % if_name, 'r') as f:
                line = f.readline()
                st = int(line.strip())
                if st == 1:
                    status = 'enabled'
                elif st == 0:
                    status = 'disabled'
    except Exception, e:
        return None, 'Error retrieving interface enabled status: %s' % str(e)
    else:
        return status, None


def update_interface_state(if_name, state):
    try:
        if (not if_name) or (not state):
            raise Exception('Interface name or state not specified')

        if state not in ['up', 'down']:
            raise Exception('Unsupported state in state change request')

        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)

        if init_type not in ['systemd', 'init']:
            raise Exception("No Systemd or Init found.")

        if init_type == 'systemd':
            cmd = 'nmcli con %s %s' % (state, if_name)
            ret, err = command.get_command_output(cmd)
            if err:
                raise Exception(err)
        else:
            cmd = 'if%s %s' % (state, if_name)
            # print cmd
            ret, err = command.get_command_output(cmd)
            if err:
                raise Exception(err)
    except Exception, e:
        return False, 'Error setting interface state: %s ' % str(e)
    else:
        return True, None


def get_interface_bootproto(if_name):
    bootproto = 'none'
    try:
        with open('/etc/sysconfig/network-scripts/ifcfg-%s' % if_name, 'r') as f:
            lines = f.readlines()
            for line in lines:
                if 'bootproto' in line.strip().lower():
                    pos = line.strip().find('=')
                    if pos != -1:
                        bootproto = line[pos + 1:].strip()
    except Exception, e:
        return None, str(e)
    else:
        return bootproto, None


def is_interface_a_vlan(if_name):
    is_vlan = False
    try:
        val = None
        with open('/etc/sysconfig/network-scripts/ifcfg-%s' % if_name, 'r') as f:
            lines = f.readlines()
            for line in lines:
                if 'vlan' in line.strip().lower():
                    pos = line.strip().find('=')
                    if pos != -1:
                        val = line[pos + 1:].strip()
        if val and val.lower() == 'yes':
            is_vlan = True
    except Exception, e:
        return None, str(e)
    else:
        return is_vlan, None


def get_interface_default_gateway(if_name):
    gateway = None
    try:
        with open('/etc/sysconfig/network-scripts/ifcfg-%s' % if_name, 'r') as f:
            lines = f.readlines()
            for line in lines:
                if 'gateway' in line.strip().lower():
                    pos = line.strip().find('=')
                    if pos != -1:
                        gateway = line[pos + 1:].strip()
    except Exception, e:
        return None, str(e)
    else:
        return gateway, None


def update_interface_ip(if_name, d):
    try:
        interfaces, err = get_interfaces()
        if err:
            raise Exception(err)
        if if_name not in interfaces:
            raise Exception('Interface not found!')
        iface = interfaces[if_name]
        if 'vlan' in iface and iface['vlan']:
            vlan = True
        else:
            vlan = False

        bm, err = get_bonding_masters()
        if err:
            raise Exception(err)
        if bm and if_name in bm:
            is_bond = True
        else:
            is_bond = False

        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)

        if init_type not in ['systemd', 'init']:
            raise Exception("No Systemd or Init found. Not editing the bond.")

        if init_type == 'systemd':
            bond_parm = ''
            if is_bond:
                bond_parm = 'connection.autoconnect-priority 99 connection.autoconnect-slaves 1'

            cmd_assert_con = 'nmcli con show %s' % if_name
            assert_con, err = command.get_command_output(cmd_assert_con)
            if err:
                cmd_con_create = 'nmcli con add type ethernet con-name %s ifname %s' % (
                    if_name, if_name)
                r, err1 = command.get_command_output(cmd_con_create)
                if err1:
                    raise Exception(err1)

            # As a best effort
            cmd_con_down = "nmcli con down %s" % if_name
            r, err = command.get_command_output(cmd_con_down)

            if_mtu = None
            if 'mtu' in d and d['mtu']:
                if_mtu = d['mtu']
            else:
                if_mtu = 1500
            cmd_set_ip = ''

            # Form connection command
            if d['addr_type'] == 'dhcp':
                # Reset the previous IP value to prevent NM from holding it as a secondary IP
                cmd_set_ip = 'nmcli con mod %s ipv4.method auto connection.autoconnect yes ipv4.never-default no ipv4.addresses "" ipv4.gateway "" ipv4.routes "" 802-3-ethernet.mtu %s ipv6.method ignore %s' % (
                if_name, if_mtu, bond_parm)
            elif d['addr_type'] == 'static':
                if_nm, err = get_subnet_in_cidr_format(d['ip'], d['netmask'])
                if err:
                    raise Exception(err)
                if_nm_route = if_nm
                if_nm = if_nm.split("/")
                if_addr = "%s/%s" % (d['ip'], if_nm[1])
                if_gw = d['default_gateway']

                cmd_set_ip = 'nmcli con mod %s ipv4.method manual connection.autoconnect yes ipv4.never-default no ipv4.addresses %s ipv4.gateway %s ipv4.routes "%s %s" 802-3-ethernet.mtu %s ipv6.method ignore %s' % (
                    if_name, if_addr, if_gw, if_nm_route, if_gw, if_mtu, bond_parm)

            r, err = command.get_command_output(cmd_set_ip)
            if err:
                raise Exception(err)

            cmd_con_up = "nmcli con up %s" % if_name
            r, err = command.get_command_output(cmd_con_up)
            if err:
                raise Exception(err)

            ret, err = restart_networking()
            if not ret:
                if err:
                    raise Exception(err)
                else:
                    raise Exception("Couldn't restart.")

        else:
            file_name = '/etc/sysconfig/network-scripts/ifcfg-%s' % if_name

            with open(file_name, 'w') as f:
                f.write('#Generated by the IntegralStor script\n')
                f.write('DEVICE=%s\n' % if_name)
                # f.write('DEVICE=%s\n'%if_name)
                if d['addr_type'] == 'static':
                    f.write('IPADDR=%s\n' % d['ip'])
                    f.write('NETMASK=%s\n' % d['netmask'])
                    f.write('BOOTPROTO=static\n')
                else:
                    f.write('BOOTPROTO=dhcp\n')
                if 'default_gateway' in d and d['default_gateway']:
                    f.write('GATEWAY=%s\n' % d['default_gateway'])
                if 'mtu' in d:
                    f.write('MTU=%s\n' % d['mtu'])
                else:
                    f.write('MTU=1500\n')
                f.write('NM_CONTROLLED=no\n')
                f.write('ONBOOT=yes\n')
                f.write('USERCTL=no\n')
                if vlan:
                    f.write('VLAN=yes\n')
                f.flush()
            f.close()
    except Exception, e:
        return False, 'Error setting IP information : %s' % str(e)
    else:
        return True, None


def create_vlan(if_name, vlan_id):
    try:
        interfaces, err = get_interfaces()
        if err:
            raise Exception(err)
        if if_name not in interfaces:
            raise Exception('Base interface not found!')

        file_name = '/etc/sysconfig/network-scripts/ifcfg-%s.%d' % (
            if_name, vlan_id)

        with open(file_name, 'w') as f:
            f.write('#Generated by the IntegralStor script\n')
            f.write('DEVICE=%s.%d\n' % (if_name, vlan_id))
            # f.write('DEVICE=%s\n'%if_name)
            f.write('BOOTPROTO=none\n')
            f.write('MTU=1500\n')
            f.write('NM_CONTROLLED=no\n')
            f.write('ONBOOT=yes\n')
            f.write('USERCTL=no\n')
            f.write('VLAN=yes\n')
            f.flush()
        f.close()
    except Exception, e:
        return False, 'Error creating VLAN interface: %s' % str(e)
    else:
        return True, None


def delete_vlan(if_name):
    try:
        if '.' not in if_name:
            raise Exception('Invalid VLAN ID')
        if not os.path.exists('/etc/sysconfig/network-scripts/ifcfg-%s' % if_name):
            raise Exception('Specified VLAN does not exist')
        os.remove('/etc/sysconfig/network-scripts/ifcfg-%s' % if_name)
        lines, err = command.get_command_output(
            'ip link set dev %s down' % if_name)
        if err:
            raise Exception(err)
        lines, err = command.get_command_output('ip link delete %s' % if_name)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error removing VLAN : %s' % str(e)
    else:
        return True, None


def default_ip_on_next_boot():
    """Default the IP of first ethernet interface

        - kernel will be set to assign the interfaces with standard
          names(eth*) instead of the fancy ones
        - first ethernet interface is configured with IP 172.16.16.16
    """
    try:
        shell_dir, err = config.get_shell_scripts_path()
        if err:
            raise Exception(err)
        cmd = '%s/no_fancy_ifnames.sh' % shell_dir
        lines, err = command.get_command_output(cmd)
        if err:
            raise Exception(err)
        cmd = 'systemctl enable first-boot'
        lines, err = command.get_command_output(cmd)
        if err:
            raise Exception(err)

    except Exception, e:
        return False, 'Could not initiate service to set default IP: %s' % str(e)
    else:
        return True, None
        

'''

  HOSTNAME/DOMAIN GET AND SET FUNCTIONS

'''


def update_hostname(hostname, domain_name):
    try:
        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)
        if init_type == 'init':
            with open('/etc/sysconfig/network', 'w') as f:
                f.write('#Generated by the IntegralStor script\n')
                f.write('NETWORKING=yes\n')
                f.write('HOSTNAME=%s\n' % hostname)
                f.flush()
            f.close()
            ret, err = command.get_command_output('hostname %s' % hostname)
            if err:
                raise Exception(err)
        else:
            if domain_name:
                hn = '%s.%s' % (hostname, domain_name)
            else:
                hn = hostname
            ret, err = command.get_command_output(
                'hostnamectl set-hostname %s --static' % hn)
            if err:
                raise Exception(err)
            ret, err = command.get_command_output(
                'systemctl restart systemd-hostnamed')
            if err:
                raise Exception(err)
            time.sleep(5)

        if os.path.isfile('/etc/salt/minion_id'):
            os.remove('/etc/salt/minion_id')
    except Exception, e:
        return False, 'Error updating hostname : %s' % str(e)
    else:
        return True, None


def get_hostname():
    hostname = None
    try:
        hostname = socket.gethostname()
        if '.' in hostname:
            # Take only the hostname part
            dot_loc = hostname.find('.')
            hostname = hostname[:dot_loc]
    except Exception, e:
        return None, 'Error retrieving hostname: %s' % str(e)
    else:
        return hostname, None


def update_hosts_file_entry(hostname, ip):
    """Add a hostname/ip entry to the /etc/hosts file. If the IP exists with another host, replace it with this one"""
    try:
        lines = None
        with open('/etc/hosts', 'r') as f:
            lines = f.readlines()
        new_lines = []
        if lines:
            added = False
            for line in lines:
                line = line.strip()
                components = line.split()
                ipc = components[0].strip()
                if ipc[0] == '#':
                    new_lines.append('%s\n' % line)
                    continue
                if ipc == ip:
                    added = True
                    new_line = '%s %s %s.integralstor.lan\n' % (
                        ip, hostname, hostname)
                else:
                    new_line = line + '\n'
                new_lines.append(new_line)
            if not added:
                new_lines.append('%s %s %s.integralstor.lan\n' %
                                 (ip, hostname, hostname))

            if new_lines:
                with open('/tmp/integralstor_newhosts', 'w') as f1:
                    for line in new_lines:
                        f1.write(line)
            shutil.move('/tmp/integralstor_newhosts', '/etc/hosts')
    except Exception, e:
        return False, 'Error adding hosts file entry: %s' % str(e)
    else:
        return True, None


def update_domain_name(domain_name):
    try:
        with open('/etc/resolv.conf', 'r') as rf:
            lines = rf.readlines()
        with open('/tmp/integralstor_newresolv', 'w') as wf:
            if domain_name:
                wf.write('domain %s\n' % domain_name)
            for line in lines:
                res = re.match('domain[\s]+([\S\w]+)', line.strip())
                if res:
                    continue
                wf.write('%s\n' % line.strip())
            wf.flush()
            wf.close()
        shutil.move('/tmp/integralstor_newresolv', '/etc/resolv.conf')
    except Exception, e:
        return False, 'Error updating domain name : %s' % str(e)
    else:
        return True, None


def get_domain_name():
    dn = None
    try:
        hostname = socket.gethostname()
        if '.' in hostname:
            dn = hostname[hostname.find('.') + 1:]
        elif os.path.isfile('/etc/resolv.conf'):
            with open('/etc/resolv.conf', 'r') as f:
                lines = f.readlines()
                for line in lines:
                    # print 'line', line
                    if line and line.strip():
                        if line.strip()[0] == '#':
                            continue
                        res = re.match('domain[\s]+([\S\w]+)', line.strip())
                        if res:
                            gr = res.groups()
                            if gr:
                                dn = gr[0]
                                break
    except Exception, e:
        return None, 'Error retrieving domain name : %s' % str(e)
    else:
        return dn, None


'''

  SET AND GET NAME SERVERS

'''


def get_name_servers():
    name_server_list = []
    try:
        with open('/etc/resolv.conf', 'r') as f:
            for line in f:
                if line.startswith('#'):
                    continue
                fields = line.strip().split()
                if fields and fields[0].lower() == 'nameserver':
                    i = 1
                    while i < len(fields):
                        name_server_list.append(fields[i])
                        i += 1
    except Exception, e:
        return None, 'Error retrieving name servers : %s' % str(e)
    else:
        return name_server_list, None


def update_name_servers(ns_list):
    try:
        dn, err = get_domain_name()
        if err:
            raise Exception(err)
        with open('/etc/resolv.conf', 'w') as f:
            f.write('#Generated by the IntegralStor script\n')
            if dn:
                f.write('domain %s\n' % dn)
            for n in ns_list:
                if n:
                    f.write('nameserver %s\n' % n)
            f.flush()
        f.close()
    except Exception, e:
        return False, 'Error updating name servers : %s' % str(e)
    else:
        return True, None


def delete_name_servers():
    try:
        with open('/etc/resolv.conf', 'w') as f:
            pass
    except Exception, e:
        return None, 'Error removing  name servers: %s' % str(e)
    else:
        return True, None


def is_enabled_jumbo_frames(ifname):
    jumbo_frames = False
    try:
        with open('/etc/sysconfig/network-scripts/ifcfg-%s' % ifname, 'r') as f:
            for line in f:
                if line.startswith('#'):
                    continue
                fields = line.strip().split('=')
                if fields[0].lower() == 'mtu':
                    if len(fields) == 2:
                        if int(fields[1]) == 9000:
                            jumbo_frames = True
                        else:
                            jumbo_frames = False
    except Exception, e:
        return None, 'Error checking jumbo frames status : %s' % str(e)
    else:
        return jumbo_frames, None


'''

  CHANGE THE CONFIGURATION FOR A NAMED DNS SERVER

'''


def generate_default_primary_named_conf(primary_ip, primary_netmask, secondary_ip, generate_forwarders=False, forwarder_ip=None, generate_zone_file=True):
    rc = 0
    try:
        primary_cidr_netmask, err = get_subnet_in_cidr_format(
            primary_ip, primary_netmask)
        if err:
            raise Exception(err)

        with open('/etc/named.conf', 'w') as f:
            f.write('// Generated by the IntegralStor script\n')
            f.write("options {\n")
            f.write(" listen-on port 53 { any; };\n")
            f.write(" listen-on-v6 port 53 { ::1; };\n")
            f.write(' directory 	"/var/named";\n')
            f.write(' dump-file 	"/var/named/data/cache_dump.db";\n')
            f.write(' statistics-file "/var/named/data/named_stats.txt";\n')
            f.write(' memstatistics-file "/var/named/data/named_mem_stats.txt";\n')
            f.write(" allow-query     { localhost; any; };\n")
            f.write(" allow-transfer  { localhost; %s; };\n" % secondary_ip)
            if generate_forwarders:
                f.write(" forwarders    { %s; };\n" % forwarder_ip)
                f.write(" recursion yes;\n")
            else:
                f.write(" recursion no;\n")
            f.write("};\n")

            f.write("logging {\n")
            f.write(" channel default_debug {\n")
            f.write('   file "data/named.run";\n')
            f.write("   severity dynamic;\n")
            f.write(" };\n")
            f.write("};\n")

            f.write('zone "." IN {\n')
            f.write(" type hint;\n")
            f.write(' file "named.ca";\n')
            f.write("};\n")

            f.write('zone "integralstor.lan" IN {\n')
            f.write(" type master;\n")
            f.write(' file "integralstor.for";\n')
            f.write(" allow-update { localhost; %s; };\n" %
                    primary_cidr_netmask)
            f.write("};\n")

            f.write('include "/etc/named.rfc1912.zones";\n')
            f.flush()
        f.close()
        if generate_zone_file:
            rc, err = generate_default_zone_file(primary_ip, secondary_ip)
            if err:
                raise Exception(err)
            if not rc:
                raise Exception('Error generating the default zone file')
        (r, rc), err = command.execute_with_rc('service named reload')
        if err:
            raise Exception(err)
        if rc != 0:
            raise Exception("Error restarting the DNS server")
    except Exception, e:
        return False, "Error generating the master DNS configuration file : %s" % str(e)
    else:
        return True, None


def generate_default_zone_file(primary_ip, secondary_ip):
    try:
        with open('/var/named/integralstor.for', 'w') as f1:
            f1.write('$ORIGIN .\n')
            f1.write('$TTL 86400    ; 1 day\n')
            f1.write(
                'integralstor.lan        IN SOA    gridcell-pri.integralstor.lan. root.integralstor.lan. (\n')
            f1.write('                                2011071026 ; serial\n')
            f1.write(
                '                                3600       ; refresh (1 hour)\n')
            f1.write(
                '                                1800       ; retry (30 minutes)\n')
            f1.write(
                '                                604800     ; expire (1 week)\n')
            f1.write(
                '                                86400      ; minimum (1 day)\n')
            f1.write('                )\n')
            f1.write('            NS    gridcell-pri.integralstor.lan.\n')
            f1.write('            NS    gridcell-sec.integralstor.lan.\n')
            f1.write('            PTR    integralstor.lan.\n')
            f1.write('$ORIGIN integralstor.lan.\n')
            f1.write('gridcell-pri          A    %s\n' % primary_ip)
            f1.write('gridcell-sec        A    %s\n' % secondary_ip)
            f1.flush()
        f1.close()
    except Exception, e:
        return False, "Error generating zone file : %s" % str(e)
    else:
        return True, None


def generate_default_secondary_named_conf(primary_ip, secondary_netmask, secondary_ip, generate_forwarders=False, forwarder_ip=None):
    try:
        secondary_cidr_netmask, err = get_subnet_in_cidr_format(
            primary_ip, secondary_netmask)
        if err:
            raise Exception(err)

        with open('/etc/named.conf', 'w') as f:
            f.write('// Generated by the IntegralStor script\n')
            f.write('options {\n')
            f.write('  listen-on port 53 { any; };\n')
            f.write('  listen-on-v6 port 53 { ::1; };\n')
            f.write('  directory 	"/var/named";\n')
            f.write('  dump-file 	"/var/named/data/cache_dump.db";\n')
            f.write('  statistics-file "/var/named/data/named_stats.txt";\n')
            f.write('  memstatistics-file "/var/named/data/named_mem_stats.txt";\n')
            f.write(
                '  allow-query     { localhost; %s; };\n' % secondary_cidr_netmask)
            if generate_forwarders:
                f.write("   forwarders    { %s; };\n" % forwarder_ip)
                f.write('  recursion yes;\n')
            else:
                f.write('  recursion no;\n')
            f.write('};\n')

            f.write('logging {\n')
            f.write('  channel default_debug {\n')
            f.write('    file "data/named.run";\n')
            f.write('    severity dynamic;\n')
            f.write('  };\n')
            f.write('};\n')

            f.write('zone "." IN {\n')
            f.write('  type hint;\n')
            f.write('  file "named.ca";\n')
            f.write('};\n')

            f.write('zone "integralstor.lan" IN {\n')
            f.write('  type slave;\n')
            f.write('  file "slaves/integralstor.for";\n')
            f.write('  masters { %s; };\n' % primary_ip)
            f.write('};\n')
            f.write('include "/etc/named.rfc1912.zones";\n')
            f.flush()
        f.close()
        (r, rc), err = command.execute_with_rc('service named restart')
        if err:
            raise Exception(err)
        if rc != 0:
            raise Exception("Error restarting the DNS server")
    except Exception, e:
        return False, "Error generating the DNS slave configuration file : %s" % e
    else:
        return True, None


'''

  GATEWAY RELATED FUNCTIONS

'''


def get_default_gateways():
    gw_dict = {}
    try:
        gd = netifaces.gateways()
        if gd and 'default' in gd:
            if netifaces.AF_INET in gd['default']:
                gw_dict['AF_INET'] = gd['default'][netifaces.AF_INET]
            if netifaces.AF_INET6 in gd['default']:
                gw_dict['AF_INET6'] = gd['default'][netifaces.AF_INET6]
            if netifaces.AF_LINK in gd['default']:
                gw_dict['AF_LINK'] = gd['default'][netifaces.AF_LINK]

    except Exception, e:
        return None, 'Error retrieving default gateways : %s' % str(e)
    else:
        return gw_dict, None


def get_all_gateways():
    gw_dict = {}
    try:
        gd = netifaces.gateways()
        for family, gw_info in gd.items():
            if family == 'default':
                continue
            if family == netifaces.AF_INET:
                gw_dict['AF_INET'] = gw_info
            elif family == netifaces.AF_INET6:
                gw_dict['AF_INET6'] = gw_info
            elif family == netifaces.AF_LINK:
                gw_dict['AF_LINK'] = gw_info

    except Exception, e:
        return None, 'Error retrieving gateways : %s' % str(e)
    else:
        return gw_dict, None


def restart_networking():

    try:
        ret, err = services_management.update_service_status(
            'network', 'restart')
        if err:
            raise Exception(err)
    except Exception, e:
        return False, "Error restarting networking services : %s" % str(e)
    else:
        return True, None

# Pass a request.META, to this function, and enable X_Http_Forward in
# nginx,and this function will return the actual client ip of the client
# and not the gateway. Works over firewall


def get_client_ip(meta):

    try:
        user_ip = meta["HTTP_X_FORWARDED_FOR"] if "HTTP_X_FORWARDED_FOR" in meta else meta["REMOTE_ADDR"]
        return user_ip, None
    except Exception, e:
        return False, "Unable to get Client IP."


def check_url(url):
    result = False
    try:
        p = urlparse(url)
        conn = httplib.HTTPConnection(p.netloc)
        conn.request('HEAD', p.path)
        resp = conn.getresponse()
        if resp.status < 400:
            result = True
    except Exception, e:
        return False, 'Error checking URL : %s' % str(e)
    else:
        return result, None


if __name__ == "__main__":
    # print validate_ip('0.1.2.3')
    # print get_bonding_type('bond0')
    # print get_ip_info('em2')
    # print get_name_servers()
    # update_hostname('check-330', 'check-dom')
    # print set_bonding_type('bond0', 6)
    # print jumbo_frames_enabled('bond0')
    # print generate_default_primary_named_conf('10.1.1.4', '255.255.255.0', '10.1.1.5')
    #set_name_servers(['192.168.1.248', '192.168.1.249', None])
    #rc = change_hosts_file_entry('gridcell-pri', '10.1.1.20', 'gridcell-pri', '10.1.1.4')
    # print rc
    #r, err = get_interfaces()
    #r, err = set_admin_servers(['1.1.1.1', '1.1.1.2', '1.1.1.3'])
    #d = {'name':'eth0.5', 'ip':'192.168.1.215','netmask':'255.255.255.0','addr_type':'static'}
    #r, err = set_interface_ip_info('eth0.5', d)
    #r, err = create_vlan('eth1', 7)
    #r, err = remove_vlan('eth1.7')
    #r, err = get_default_gateways()
    #r, err = get_all_gateways()
    #r, err = get_interface_carrier_status('eth0')
    #r, err = get_interface_up_status('eth1')
    #r, err = get_bonding_masters()
    #r, err = get_bonding_info('bond1')
    #r, err = get_bonding_info_all()
    #r, err = create_bond('bond1', ['eth0', 'eth1'], 6, False, ['192.168.1.246', '255.255.255.0', '192.168.1.7'])
    #r, err = remove_bond('bond0')
    #r, err = get_domain_name()
    #pp = pprint.PrettyPrinter(indent=4)
    # pp.pprint(r)
    # pp.pprint(err)
    # print err
    # print validate_hostname('jash-kh')
    # print regenerate_hosts_file()
    # print delete_all_bonds()
    # print delete_interface_connection('eno67109432')
    # print delete_interfaces_connection()
    # print default_ip_on_next_boot()
    print delete_interfaces_connection(if_name='eth1')


# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
