from integralstor_utils import config, db, command
from integralstor import audit

import re
import time
import datetime
import socket
import getpass
import os


def is_task_running(cron_task_id, task_type_id, check_execution=False):
    """Check if any entry in the tasks table with cron_task_id has
    status field value as 'running'

    args:       cron_task_id of integer type
                task_type_id of integer type
                check_execution of boolean type
                    - when set, also considers 'error-retrying' and
                    'queued' states.

    returns:    (ret1, ret2) - (True/False/None, "Error_String"/None)
                ret1:   True if a task has status as 'running', else
                        False if no task has status as 'running', or
                        None if exceptions were raised

                ret2:   None if no exceptions were raised, else
                        Error string 
    """
    is_running = False
    try:
        existing_tasks = None
        existing_tasks, err = get_tasks_by_cron_task_id(cron_task_id)
        if err is not None:
            raise Exception(err)
        if existing_tasks:
            for task in existing_tasks:
                # Check if a background task with the same cron_task_id is yet to complete its replication
                if check_execution is True and str(task['status']) in ['running', 'queued', 'error-retrying'] and str(task['task_type_id']) == str(task_type_id):
                    is_running = True
                elif check_execution is False and str(task['status']) in ['running'] and str(task['task_type_id']) == str(task_type_id):
                    is_running = True

    except Exception, e:
        return None, str(e)
    else:
        return is_running, None


def create_task(description, subtask_list, task_type_id=0, cron_task_id=0, node=socket.getfqdn(), initiate_time=None, attempts=3, run_as_user_name='root', retry_interval=1):
    """Adds a task in to tasks table which performs/runs the subtask_list according to the received arguments."""
    row_id = -1
    try:
        if not description or not subtask_list:
            raise Exception("Insufficient parameters")

        now = int(time.time())
        if not initiate_time:
            initiate_time = now

        log_path, err = config.get_log_folder_path()
        if err:
            raise Exception(err)
        log_dir = '%s/task_logs' % log_path
        if not os.path.isdir(log_dir):
            os.mkdir(log_dir)

        cmd = "insert into tasks (description,task_type_id, node, run_as_user_name, attempts, cron_task_id, retry_interval, create_time, initiate_time) VALUES ('%s','%d','%s','%s','%d','%d','%d', '%d', '%d');" % (
            description, task_type_id, node, run_as_user_name, attempts, int(cron_task_id), retry_interval, now, initiate_time)
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        row_id, err = db.execute_iud(db_path, [[cmd], ], get_rowid=True)
        if err:
            raise Exception(err)

        if row_id:
            log_file = '%s/%d.log' % (log_dir, row_id)
            for subtask in subtask_list:
                for description, command in subtask.iteritems():
                    command = '%s  &> %s' % (command, log_file)
                    cmd = "insert into subtasks (description,command,task_id) values ('%s','%s','%d');" % (
                        description, command, row_id)
                    status, err = db.execute_iud(
                        db_path, [[cmd], ], get_rowid=True)
                    if err:
                        raise Exception(
                            'Error creating scheduled command : %s' % err)
        else:
            raise Exception('Error creating scheduled task')
    except Exception, e:
        return False, ' Error adding task: %s' % e
    else:
        return True, None


def delete_task(task_id):
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        # Deleting entries from tasks table will also remove related
        # entries in subtasks table; cascading deletions.
        cmd_list = [['delete from tasks where task_id = %s' % task_id], ]

        status, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error removing task : %s' % e
    else:
        return True, None


def delete_all_tasks():
    """Delete all entries from tasks and subtasks table

    """
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        # Deleting entries from tasks table will also remove related
        # entries in subtasks table; cascading deletions.
        cmd_list = [['delete from tasks'], ]

        status, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error removing tasks: %s' % e
    else:
        return True, None


def get_tasks(node=None):
    """Returns all entries from tasks table."""
    tasks = None
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        #start_time = int((datetime.datetime.now() - datetime.timedelta(minutes=minutes)).strftime("%s"))
        #end_time = int((datetime.datetime.now() + datetime.timedelta(minutes=minutes)).strftime("%s"))

        if not node:
            tasks_query = "select * from tasks order by initiate_time desc"
        else:
            tasks_query = "select * from scheduler_tasks order by initiate_time desc"

        tasks, err = db.get_multiple_rows(db_path, tasks_query)
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving tasks : %s' % e
    else:
        return tasks, None


def get_tasks_by_cron_task_id(cron_task_id, get_last_by=False):
    tasks = []
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        if get_last_by is False:
            query = 'select * from tasks where cron_task_id="%d"' % int(
                cron_task_id)
        else:
            query = 'select * from tasks where cron_task_id="%d" order by "%s" desc limit 1' % (
                int(cron_task_id), str(get_last_by))

        tasks, err = db.get_multiple_rows(db_path, query)
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving tasks by cron task id: %s' % e
    else:
        return tasks, None


def get_task(task_id):
    """Get a particular entry with the passed task_id from the tasks table."""
    task = None
    try:

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        cmd = "select * from tasks where task_id=='%d'" % int(task_id)
        task, err = db.get_single_row(db_path, cmd)
        if err:
            raise Exception(err)
        if not task:
            raise Exception('Selected task not found')
    except Exception, e:
        return None, 'Error retrieving task details : %s' % e
    else:
        return task, None


def get_subtasks(task_id):
    """For the given task_id, fetch all the entires from subtasks with matching task_id value."""
    subtasks = None
    try:
        query = "select * from subtasks where task_id = '%d'" % task_id

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        subtasks, err = db.get_multiple_rows(db_path, query)
        if err:
            raise Exception(err)
        if not subtasks:
            raise Exception('No subtasks found for the specified task.')
    except Exception, e:
        return None, 'Error retrieving subtasks : %s' % e
    else:
        return subtasks, None


def process_tasks(node=socket.getfqdn()):
    """When called, processes/runs subtasks of each entry from tasks table if they satisfy/pass the required checks like status, last_run_time, retries, etc."""
    '''
    TODO
        - Needs a better docstring comment beriefly explaning what the function does
    '''
    try:

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        current_user = getpass.getuser()
        now = int(time.time())

        tasks_query = "select * from tasks where node == '" + node + \
            "' and (status == 'error-retrying' or status == 'queued') and (initiate_time <= '%d');" % (now)
        tasks_to_process, err = db.get_multiple_rows(db_path, tasks_query)
        if err:
            raise Exception(err)

        if tasks_to_process is not None:

            for task in tasks_to_process:

                if task['last_run_time']:
                    seconds_since_last_run = (now - task['last_run_time'])
                    # retry_interval is in minutes!
                    if seconds_since_last_run < task['retry_interval'] * 60:
                        continue

                # Mark the task as running
                cmd = "update tasks set status = 'running', last_run_time=%d where task_id = '%d'" % (
                    now, task['task_id'])
                status, err = db.execute_iud(
                    db_path, [[cmd], ], get_rowid=True)
                if err:
                    raise Exception(err)

                audit_str = "%s" % task['description']
                audit.audit("task_start", audit_str,
                            None, system_initiated=True)

                attempts = task['attempts']
                run_as_user_name = task['run_as_user_name']

                # Now process subtasks for the task
                subtasks_query = "select * from subtasks where task_id == '%d' and (status == 'error-retrying' or status == 'queued') order by subtask_id" % task[
                    'task_id']
                subtasks, err = db.get_multiple_rows(db_path, subtasks_query)
                if err:
                    raise Exception(err)

                # Assume task is complete unless proven otherwise
                task_completed = True

                # Iteriate through all the unfinished subtasks related to the
                # task
                for subtask in subtasks:

                    subtask_id = subtask["subtask_id"]

                    status_update = "update subtasks set status = 'running' where subtask_id = '%d' and status is not 'cancelled'" % subtask_id
                    status, err = db.execute_iud(
                        db_path, [[status_update], ], get_rowid=True)
                    if err:
                        task_completed = False
                        break

                    # Now actually execute the command
                    # This task is not meant to be executed by the current user so switch to that user
                    (out, return_code), err = command.execute_with_rc(
                        subtask["command"], shell=True, run_as_user_name=run_as_user_name)

                    if out[0]:
                        output = re.sub("'", "", ''.join(out[0]))
                    else:
                        output = None
                    if out[1]:
                        error = re.sub("'", "", ''.join(out[1]))
                    else:
                        error = None

                    if return_code == 0:
                        # This means the command was successful. So update to
                        # completed
                        status_update = "update subtasks set status = 'completed', return_code='%d' where subtask_id = '%d' and status is not 'cancelled';" % (
                            return_code, subtask_id)
                        status, err = db.execute_iud(
                            db_path, [[status_update], ], get_rowid=True)
                        if err:
                            task_completed = False
                            break
                        else:
                            continue
                    else:
                        # Subtask command failed
                        if attempts > 1 or attempts == -2:
                            status_update = 'update subtasks set status = "error-retrying", return_code="%d" where subtask_id = "%d" and status is not "cancelled";' % (
                                return_code, subtask_id)
                        elif attempts in [0, 1]:
                            status_update = 'update scheduler_commands set status = "failed", return_code="%d"" where subtask_id = "%d" and status is not "cancelled";' % (
                                return_code, subtask_id)
                        execute, err = db.execute_iud(
                            db_path, [[status_update], ], get_rowid=True)
                        task_completed = False
                        break

                if task_completed:
                    status_update = "update tasks set status = 'completed' where task_id = '%d'" % task[
                        'task_id']
                else:
                    if attempts > 1:
                        status_update = "update tasks set status = 'error-retrying', attempts = %d where task_id = '%d' and status is not 'cancelled'" % (
                            attempts - 1, task['task_id'])
                    elif attempts == -2:
                        status_update = "update tasks set status = 'error-retrying', attempts = %d where task_id = '%d' and status is not 'cancelled'" % (
                            -2, task['task_id'])
                    else:
                        status_update = "update tasks set status = 'failed', attempts = '%d' where task_id = '%d' and status is not 'cancelled'" % (
                            0, task['task_id'])
                status, err = db.execute_iud(
                    db_path, [[status_update], ], get_rowid=True)
                if err:
                    raise Exception(err)

                if task_completed:
                    audit.audit("task_complete", audit_str,
                                None, system_initiated=True)
                else:
                    audit.audit("task_fail", audit_str,
                                None, system_initiated=True)

    except Exception as e:
        return False, 'Error processing tasks : %s' % e
    else:
        return True, None


def main():
    # process_tasks()
    # get_tasks()
    # print delete_task(5)
    # print delete_all_tasks()
    print is_task_running(1)


if __name__ == "__main__":
    main()

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
